(* This implementation supports tris, quads, and higher polys, as well as surfaces with holes. 
The function relies on three externally defined general functionality functions: *)

subSetQ[large_,small_] := MemberQ[large,small]
subSetQ[large_,small_List] := And@@(MemberQ[large,#]&/@small)
 
containing[groupList_,item_]:= Flatten[Position[groupList,group_/;subSetQ[group,item]]]
 
ReplaceFace[face_]:=Transpose[Prepend[Transpose[{#[[1]],face,#[[2]]}&/@Transpose[Partition[face,2,1,1]//{#,RotateRight[#]}&]],face]]

(* subSetQ[small,large] is a boolean test for whether small is a subset of large. 
Note this is not a general purpose implimentation and only serves this purpose under the constrictions of the 
following program.

containing[{obj1,obj2,...},item] Will return a list of indices of the objects containing item, 
where objects are faces or edges and item is edges or vertexes. faces containing a given vertex, 
faces containing a given edge, edges containing a given point. It is used for each such purpose in the code 
called via infix notation, the specific usage is easily distinguised by variable names. 
For example faces~containing~edge would be a list of the indices for the faces containing the given edge.

ReplaceFace[face] replaces the face with a list of descriptions for the new faces. It will return a 
list containing mixed objects, vertexes, edges and faces where edges and faces referes to the new vertexes 
to be generated by the code. When the new vertexes have been appended to the updated old vertexes, 
these mixed objects will be recalcluated into correct indices into the new vertex list by the later 
defined function newIndex[]. *)

CatMullClark[{Points_,faces_}]:=Block[{avgFacePoints,avgEdgePoints,updatedPoints,newEdgePoints,newPoints,edges,newFaces,weights,pointUpdate,edgeUpdate,newIndex},
edges = DeleteDuplicates[Flatten[Partition[#,2,1,-1]&/@faces,1],Sort[#1]==Sort[#2]&];
avgFacePoints=Mean[Points[[#]]] &/@ faces;
avgEdgePoints=Mean[Points[[#]]] &/@ edges;
 
weights[vertex_]:= Count[faces,vertex,2]//{(#-3),1,2}/#&;
pointUpdate[vertex_]:= 
	If[Length[faces~containing~vertex]!=Length[edges~containing~vertex],
		Mean[avgEdgePoints[[Select[edges~containing~vertex,holeQ[edges[[#]],faces]&]]]],
		Total[weights[vertex]{ Points[[vertex]], Mean[avgFacePoints[[faces~containing~vertex]]], Mean[avgEdgePoints[[edges~containing~vertex]]]}]
	];
 
edgeUpdate[edge_]:= 
	If[Length[faces~containing~edge]==1,
		Mean[Points[[edge]]],
		Mean[Points[[Flatten[{edge, faces[[faces~containing~edge]]}]]]]
	];
 
updatedPoints = pointUpdate/@Range[1,Length[Points]];
newEdgePoints = edgeUpdate/@edges;
newPoints = Join[updatedPoints,avgFacePoints,newEdgePoints];
 
newIndex[edge_/;Length[edge]==2]  := Length[Points]+Length[faces]+Position[Sort/@edges,Sort@edge][[1,1]]
newIndex[face_] := Length[Points]+Position[faces,face][[1,1]]
 
newFaces  = Flatten[Map[newIndex[#,{Points,edges,faces}]&,ReplaceFace/@faces,{-2}],1];
{newPoints,newFaces}
]

(* The implimentation can be tested with polygons with and without holes by using the polydata *)
{points,faces}=PolyhedronData["Cube",{"VertexCoordinates","FaceIndices"}];
 
Function[iteration,
Graphics3D[(Polygon[iteration[[1]][[#]]]&/@iteration[[2]])]
]/@NestList[CatMullClark,{points,faces},3]//GraphicsRow
